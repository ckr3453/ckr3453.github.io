---
title: "연관관계 관리 - 프록시 (작성중)"
categories: 
    - jpa
date: 2022-10-26
last_modified_at: 2022-10-26
# tags:
#     - 태그1
#     - 태그2
#     - tag_test..
toc: true
toc_sticky: true
# toc_label: "MYSELF"
excerpt: "프록시에 대해 알아보자."
---

## 프록시를 사용해야하는 이유

(이미지)

Member와 Team이라는 테이블이 있다고 가정하자. (Member는 자신이 소속되어 있는 Team이 있다. = N:1의 관계)

이때 Member와 Team 객체를 출력하는 비즈니스 로직이 있다고 할 때 다음과 같이 작성할 수 있다.

```java
private static void printMemberAndTeam(Member member){
    System.out.println("username = "+ member.getUsername());
    System.out.println("username = "+ member.getTeam().getName());
}

...

Member member = entityManager.find(Member.class, 1L); // member와 team 조회 join 쿼리 수행
printMemberAndTeam(member);
```

JPA 에서는 member의 이름과 team 이름을 구하기 위해 **join 쿼리를 날리게 된다.**

`printMemberAndTeam` 메서드를 수행하기엔 적합한 쿼리였지만 **Member의 정보만 필요한 경우에는 join 쿼리는 오히려 낭비**가 될 것이다.

어떻게하면 때에 따라 낭비 없이 최적화를 할 수 있을까?

JPA에서는 프록시와 지연로딩이라는 개념으로 해결할 수 있다.

## 프록시

(이미지)

`EntityManager`는 proxy를 활용한 객체 조회를 위해 `getReference()` 기능을 제공한다.

- entityManager.find()
  - 데이터베이스를 통해서 실제 엔티티 객체를 조회한다.

- entityManager.getReference()
  - 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체를 조회한다.
  - 즉, 데이터베이스로 쿼리를 날리지 않고 객체 조회가 가능하다.



```java

// jpa가 member와 team을 한번에 가져오기 위해 join 쿼리를 날린다.
Member findMember = entityManager.find(Member.class, 1L);

// jpa가 객체를 가져오는 시점에는 쿼리를 날리지 않고 "실제로 사용하는 시점"에 쿼리를 날린다.
Member findMember = entityManager.getReference(Member.class, 1L);

System.out.println("findMember.id = "+ findMember.getId());
System.out.println("findMember.name = "+ findMember.getUsername());
```

## 📣 Reference
본 포스팅은 김영한님의 강의를 듣고 스스로 정리 및 추가한 내용입니다.

[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)<br/>
