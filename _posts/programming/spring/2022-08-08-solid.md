---
title: "좋은 객체 지향 설계의 5가지 원칙(SOLID)"
categories: 
    - Spring
date: 2022-08-08
last_modified_at: 2022-08-08
# tags:
#     - 태그1
#     - 태그2
#     - tag_test..
toc: true
toc_sticky: true
# toc_label: "MYSELF"
---

## SOLID 란
클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 아래와 같이 정리하였다.

- SRP(Single Responsibility Principle) : 단일 책임 원칙
- OCP(Open/Closed Principle) : 개방/폐쇄 원칙
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle) : 의존관계 역전 원칙

위와 같은 5가지 원칙 SOLID를 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 큰 도움이 된다.

## SRP(Single Responsibility Principle) - 단일 책임 원칙
SRP에 대해 찾아보면 SRP는 문자 그대로 **클래스는 하나의 책임만 가져야 한다.** 로 정의하고 있다. 

즉, 각각의 클래스들은 단 하나의 책임을 수행하는데 집중되어야 한다는 의미로 클래스를 변경하려는 이유또한 단 하나여야 한다.

#### SRP 적용 전
```java
class Employee {
    public String getName(){...}
    public String getDepartment(){...}
    public void getCoffee(){...}
    public void printReport(){...}
    public void saveFile(){...}
}
```

위 코드의 경우 getName 기능을 수정하기 위해서도 Employee 클래스를 수정하여야 하고 printReport 기능을 수정하기 위해서도 같은 클래스를 수정하여야 한다.

또한 각 기능들의 관심사가 유사할수록 정보를 가져오거나 혹은 변경이 일어날때 어딘가에서 서로 연결될 확률이 높다. 

이러한 결합은 많은 변경사항을 발생시키며 변경에 의한 연쇄작용으로 인해 결국 유지보수 및 테스트가 어려워지는 문제점이 발생한다.

#### SRP 적용 후
```java
class Employee {
    public String getName(){...}
    public String getDepartment(){...}
    public void getCoffee(){...}
}

class Printer {
    public void printReport(){...}
}

class Computer {
    public void saveFile(){...}
}
```

- 하나의 책임이라는 것은 모호하다. 적절하게 범위를 설정하여야 한다. (범위가 너무 크면 책임이 많아지고 범위가 작으면 클래스가 여러개로 나뉨)
  - 클 수 있고, 작을 수 있다.
  - 문맥과 상황에 따라 다르다.
- **중요한 기준은 변경**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 이다.
  - ex) UI 변경, 객체의 생성과 사용을 분리
- SRP 원칙을 적용 했을 때 응집도는 높이고 결합도를 낮추는 결과를 가져온다.


## OCP(Open/Closed Principle) - 개방/폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
  - 이런 거짓말 같은 말이? 확장을 하려면 당연히 기존 코드를 변경하여야 하지않는가?
- 다형성을 활용해보자
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 기존 코드(인터페이스)를 변경하는게 아님 (변경에는 닫혀 있다.)
  - 인터페이스 상속을 통한 확장 (확장에는 열려 있다.)
- 지금까지 배운 역할과 구현의 분리를 생각해보자

문제점
- MemberService 클라이언트가 구현 클래스를 직접 선택 (MemberService.java)
  - MemberRepository m = new MemoryMemberRepository(); //기존 코드
  - MemberRepository m = new JdbcMemberRepository(); //변경 코드
- 구현 객체를 변경하려면 클라이언트 코드를 변경해야한다.
- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
- 이 문제를 어떻게 해결해야되나?
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. (스프링 지원)

## LSP(Liskov Substitution Principle) - 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능이다. 이를 뒤로 가게 구현하면 LSP 위반이며, 느리더라도 앞으로 가야한다.

## ISP(Interface Segregation Principle) - 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

## DIP(Dependency Inversion Principle) - 의존관계 역전 원칙
- 프로그래머는 **"추상화에 의존해야지, 구체화에 의존하면 안된다."** 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미
- 앞에서 이야기한 역할(Role)에 의존하게 해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워 진다.
- 역할과 구현을 철저히 분리

문제점
- 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
- MemberService 클라이언트가 구현 클래스를 직접 선택
  - MemberRepository m = new MemoryMemberRepository(); //DIP 위반

## 정리
- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 OCP,DIP를 지킬 수 없다.
- 뭔가 더 필요하다.

## 📣 Reference
본 포스팅은 김영한님의 강의를 듣고 스스로 정리한 내용입니다.

> [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
